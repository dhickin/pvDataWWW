<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
  <title>EPICS PVData</title>
</head>

<body>
<img src="logo101.gif" alt="EPICS" align="right" height="101" width="101"> <a
href="http://sourceforge.net/projects/epics-pvdata"><img
src="http://sflogo.sourceforge.net/sflogo.php?group_id=249167&amp;type=10"
width="80" height="15" align="left"
alt="Get EPICS-pvData at SourceForge.net. Fast, secure and Free Open Source software downloads"></a> 

<h2 align="center">EPICS PVData</h2>

<h2 align="center">2011.08.05</h2>

<h3>Introduction</h3>

<p>EPICS PVData is a software tool kit for implementing a Distributed Control
System.</p>

<p>The toolkit consists of the following components:</p>
<dl>
  <dt>pvData</dt>
    <dd>Definition and implementation of memory resident structured data.</dd>
  <dt>pvAccess</dt>
    <dd>Channel Access Version 4: Network Support for pvData. Note</dd>
  <dt>pvIOC</dt>
    <dd>An Input Output Controller (IOC) that supports pvData and implements
      "smart" records.</dd>
  <dt>pvService</dt>
    <dd>A set of services for High Level Applications.</dd>
</dl>

<p>A pvIOC is an implementation of an EPICS Input Output Controller (IOC). A
pvIOC is similar to an EPICS Version 3 IOC ( the 3.13 and 3.14 releases of
EPICS base) but extends the data types to support structured data. The
pvService component provides a service layer for accessing a set of V3 IOCs
and/ot pvIOCs<a href="http://www.aps.anl.gov/epics"></a></p>

<p><a href="http://www.aps.anl.gov/epics">EPICS</a> is a set of Open Source
software tools, libraries and applications developed collaboratively and used
worldwide to create distributed soft real-time control systems for scientific
instruments such as a particle accelerators, telescopes and other large
scientific experiments. An IOC (Input/Output Controller) is a network node that
controls and/or monitors a collection of devices. An IOC contains a memory
resident real time database. The real time database has a set of "smart"
records.</p>

<h3>Uses</h3>

<p>Some uses are:</p>
<dl>
  <dt>Service Layer</dt>
    <dd>This is the current emphasis. An example is the gather service. It
      allows a gather client to get/put/monitor the values of a set of V3
      records. The data is given to the client as an array.</dd>
  <dt>I/O Controller</dt>
    <dd>The pvIOC can be used as a soft real-time Input/Output controller. It
      implements portDriver, which is a facility for accessing hardware I/O
      devices such as Analog, Digital, Serial, GPIB, etc. (Much work remains on
      implementing low level drivers).</dd>
  <dt>Distributed Control System</dt>
    <dd>EPICS PVData provides a toolkit for building a DCS.</dd>
  <dt>SCADA</dt>
    <dd>EPICS PVData can be used to implement Supervisory Control And Data
      Acquisition (SCADA) applications.</dd>
  <dt>Data Server</dt>
    <dd>An application can use the pvIOC or just channelAccess/pvData to serve
      data to network clients.</dd>
  <dt>Gateway</dt>
    <dd>A pvIOC can be the basis for transfering data between different types
      of control systems. </dd>
</dl>

<h3>SourceForge Projects</h3>

<p>The implementation code consists of a combination of Java, C++, and Python.
The Java implementation is the most complete. C++ implementations of pvData and
pvAccess are also complete. The C++ implementations of pvIOC and pvService are
in the early stages of development. The Python implementation of pvData and
pvAccess is in progress. The client side of the gather service has been
implemented in both C++ and Python.</p>

<p>At the present time code is only available via source-forge.</p>

<h4>Java</h4>

<p>The Java code uses a CVS repository and is developed as eclipse projects:
</p>
<dl>
  <dt>pvData</dt>
  <dt></dt>
  <dt>pvAccess</dt>
  <dt>javaIOC</dt>
    <dd>This is the Java version of pvIOC</dd>
</dl>
To install the software create eclipse projects. The steps are:
<ul>
  <li>Install eclipse</li>
</ul>
<pre>    Authentication:
              User: anonymous
          Password: Just click enter key.
   Connection Type:  extssh
              Host: epics-pvdata.cvs.sourceforge.net
   Repository Path: /cvsroot/epics-pvdata
</pre>
<ul>
  <li>In eclipse select Window=&gt;Open Perspective=&gt;SynchronizeView</li>
  <li>Select the newly created repository</li>
  <li>Go to versions and for each of pvData, pvAccess, javaIOC, and PVService 
    <ul>
      <li>Find the version you want</li>
      <li>With right mouse button select check out as</li>
    </ul>
  </li>
  <li>make pvAccess depend on pvData</li>
  <li>Make javaIOC depend on pvData and pvAccess.</li>
  <li>Make pvService depend on pvData, pvAccess, and javaIOC.</li>
</ul>

<h4>C++ and Python</h4>

<p>The C++ and Python code uses a mercurial repository. The EPICS V3 build
system is used as the development system. V3 libCom is used for threading and
other support. Thus it requires that You have a recent release of EPICS base.
The following sourceforge mercurial repositories exist:</p>
<dl>
  <dt>epics-pvdata/pvDataCPP</dt>
  <dt>epics-pvdata/pvAccessCPP</dt>
  <dt>epics-pvdata/pvIOCCPP</dt>
  <dt>epics-pvdata/pvServiceCPP</dt>
</dl>

<p>As an example of how to check out pvDataCPP I can execute:</p>
<pre>mrk&gt; pwd
/home/mrk/hg/pvDataTemp
mrk&gt; hg clone ssh://mrkraimer@epics-pvdata.hg.sourceforge.net/hgroot/epics-pvdata/pvDataCPP</pre>

<h3>Features</h3>
<dl>
  <dt>PVData</dt>
    <dd>PVData (Process Variable Data) defines and implements an efficent way
      to store, access, and create memory resident structured data.</dd>
  <dt>channel access - network access</dt>
    <dd>pvAccess implements a version of channel access that provides network
      support for transfering PVData.</dd>
  <dt>interface definitions</dt>
    <dd>The Java package org.epics.pvData.pv has Java interface definitions
      that define PVData. Package org.epics.ca.client has java interface
      definitions that define channelAccess. pvDataCPP provides the C++
      definitions.</dd>
  <dt>implementation</dt>
    <dd>Projects pvData and pvDataCPP each provide a complete implementation of
      pvData. Projects pvAccess and pvAccessCPP provides network support for
      pvData. The network protocal for the two languages is identical. Project
      pvIOC implements a smart memory resident soft real time database. Each
      field of each record can optionally have attached support code which is
      called when a record is processed. The java version (javaIOC) has much
      more functionality than pvIOCCP, which is in it's early stages of
      development. </dd>
  <dt>efficient</dt>
    <dd>Small memory footprint, low cpu overhead, and concise code base.</dd>
  <dt>data storage</dt>
    <dd>PVData defines separate introspection and data interfaces. The
      introspection interfaces provide access to immutable objects, which
      allows introspection instances to be freely shared. The introspection
      interface for a process variable can be accessed without requiring access
      to the data.</dd>
  <dt>data access</dt>
    <dd>Client code can access PVData via the introspection and data
      interfaces. For "well known" data, e.g. timeStamp, specialized interfaces
      can be provided without requiring any changes to the core software.</dd>
  <dt>data transfer</dt>
    <dd>The separation of introspection and data interfaces allows for
      efficient network data transfer. At connection time introspection
      information can be passed from server to client. Each side can create a
      data instance. The data is transferred between these instances. The data
      in the network buffers does not have to be self describing since each
      side has the introspection information.</dd>
  <dt>memory resident</dt>
    <dd>PVData only defines memory resident data.</dd>
  <dt>structured data</dt>
    <dd>PVData has three types: scalar, array, and structure. A scalar can be
      one of the following: boolean, byte, short, int, long, float, double,
      string. An array is a one dimensional array with the element type being
      one of the scalar types. A structure is an ordered set of fields where
      each field has a name and type. Since a field can have type structure
      complex structures are supported. No other types are needed since
      structures can be defined that simulate types.</dd>
</dl>

<h3>Getting Started</h3>

<p>The javaIOC project provides a GUI based shell. See Getting Started in <a
href="javaIOC/doc/index.html">javaIOC/doc/index.html</a> For how to start it
with an example database.</p>

<p>Each project has a JavaDoc overview document and each java package has a
package overview document. It is suggested that you first read the project
overview document first: pvData, then channelAccess, and then javaIOC. The
latest javaDOC is available via links in the next section.</p>

<h3>EPICS PVData Projects</h3>

<p>The following is the documentation as of 2011.08.05:</p>
<dl>
  <dt><a href="pvData/doc/index.html">pvData</a></dt>
  <dt><a href="pvAccess/doc/index.html">pvAccess</a></dt>
  <dt><a href="javaIOC/doc/index.html">javaIOC</a></dt>
  <dt><a href="pvService/doc/index.html">pvService</a></dt>
  <dt><a href="pvDataCpp.html">pvDataCPP.html</a></dt>
  <dt><a href="pvIOCCP.html">pvIOCCP.html</a></dt>
  <dt><a href="pvServiceCPP.html">pvServiceCPP.html</a></dt>
  <dt><a href="pvServicePy.html">pvServicePy.html</a></dt>
</dl>
</body>
</html>
