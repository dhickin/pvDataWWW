<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="text/html">
  <title>caV4R0-8-0</title>
</head>
<img src="../../logo101.gif" alt="EPICS" align="right" height="101" width="101"> 

<a href="http://sourceforge.net/projects/epics-pvdata"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=249167&amp;type=10" width="80" height="15" align = "left" alt="Get EPICS-pvData at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a>

<body>

<h2 align="center">caV4R0-8-0: Known Problems</h2>
<h2 align="center">2009.10.05</h2>
<p>
The changes discussed below mean that future releases will not be backwards
compatible with this release. Both the network protocol and client
interfaces will change.</p>
<h3>Query Facility</h3>

<p>This needs to be defined and implemented.</p>

<h3>Access Security</h3>

<p>Something like how caV3 implements access security is required. A
complication is that for caV3 a client attaches to a single scalar or array
field. For caV4 a client attaches to an arbirary set of fields in a record.
Takes some thought to decide what to do.</p>

<h3>TCP Transport</h3>

<p>Currently a client asks for a network buffer, puts data into it, and then
releases the buffer. The caV4 transport layer then sends the network buffer.
This has at least the following problems:</p>
<ul>
  <li>large arrays<br />
    Since a message must fit in a single network buffer, a network buffer as
    large as the largest array must be alloxated.</li>
  <li>The client can block waiting for a network buffer.</li>
</ul>

<p>This will be changed so that a client queues a request to issue a network
send request. When the client is called back, the client can issue multiple
send requests and has exclusive access to. When the client is called back,
the client can issue multiple send requests. The transport layer has two
threads for each network port, a send thread and a receiove thread. The send
thread is what calls the users send request callback.</p>

<p>This implementation has the following desirable features:</p>
<ul>
  <li>Client does not block<br />
    A queue request does not block. Of course the callback does block but
    this is blocking the send thread not a user thread.</li>
  <li>Easy nertwork buffer management.<br />
    All that is required is a single send buffer and a single receive buffer
    for each network port. The size can just be the network MTU (Maximum
    Transmission Unit) size.</li>
  <li>No Flush<br />
    The user never needs to flush a buffer.</li>
  <li>Efficent network usage.<br />
    As long as clients are queued, the send thread can combine user requests
    into the network buffer. Only when no more clients are queued is the
    buffer flushed.</li>
</ul>
<h3>User Controlled Send Queues</h3>

<p>Currently a user can only ask to send a message immediately, i. e. a
client has no control over when a message is sent. This can result in many
short network packets. Perhaps the following should be provided: Allow a
client, for each send request, to specify the following options:</p>
<dl>
  <dt>immediate</dt>
    <dd>Immediately queue a request to the send thread.</dd>
  <dt>periodically</dt>
    <dd>Put requests on a periodic send queue. At some periodic rate the
      queue is transfered to the send thread.</dd>
  <dt>user queue</dt>
    <dd>Client keeps a private queue for requests. The client decides when
      the queue should be transfered to the send thread.</dd>
</dl>
</body>
</html>
