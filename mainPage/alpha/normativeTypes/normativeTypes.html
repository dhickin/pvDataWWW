<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>

  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta name="keywords" content="EPICS, EPICSv4" />
  <title>EPICS V4 Normative Types</title>
  <link rel="stylesheet" type="text/css" href="../../base.css" />
  <link rel="stylesheet" type="text/css"   href="../../epicsv4.css" />

  <!-- Styles comments:
   opt - Markup for standard optional fields of Normative Types
   nterm - Non-terminal symbol, in the grammar of Normative types
   term - Terminal symbol in the grammar of Normative Types
   user - A replacement string in the grammar of Normative Types,
          ie user programmer supplies value.
   ed   - Comments included by the editor of this document.
  -->
  <style type="text/css">
  /*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     span.opt { color: grey }            
     span.nterm { font-style:italic }    
     span.term { font-family:courier }   
     span.user { font-family:courier }   
     span.user:before { content:"<" }
     span.user:after { content:">" }
     .nonnorm { font-style:italic }
     p.ed { color: #AA0000 }
     span.ed { color: #AA0000 }
     p.ed.priv { display: inline; }
     span.ed.priv { display: inline; }
  /*]]>*/</style>

  <!-- Script that generates the Table of Contents -->
  <script type="text/javascript" src="../../script/tocgen.js"></script>

</head>
		
<body>

  <div class="head">
    <h1>EPICS V4 Normative Types</h1>

      <h2 class="nocount">EPICS V4 Normative Types, Editors Draft, 27-May-2012</h2>
      <dl>
	<dt>Latest version:</dt>
	  <dd><a href="normativeTypes.html">normativeTypes.html</a></dd>
	<dt>This version:</dt>
	  <dd><a href="normativeTypes_20120527.html">normativeTypes_20120527.html</a></dd>
	<dt>Previous version:</dt>
	  <dd><a href="normativeTypes_20120418.html">normativeTypes_20120418.html</a></dd>
	<dt>Editors:</dt>
	  <dd>Greg White, SLAC, PSI</dd>
	  <dd>Bob Dalesio, BNL</dd>
	  <dd>James Rowland, Diamond</dd>
	  <dd>Marty Kraimer, BNL</dd>
	  <dd>Mark Rivers, APS (Invited Expert)</dd>
      </dl>

      <h2 class="nocount">Abstract</h2>

      <p>This document defines a standard set of data types and data structures, to
      aid interoperability of peers at the application level of an EPICS V4 network.</p>

      <p>The types described here are approximately equivalent to EPICS V3 "DBR
      types", though Normative Types extend the concept to structured
      data. Additionally, these types may be used to define pvIOC records, or may be
      used purely for data exchange though the dynamic data exchange interfaces
      offered by pvAccess and pvData.</p>

      <p>The function of each Normative Types is described, and their type data
      structures are defined.</p>

      <p>For more information about EPICS, please refer to the home page of the <a
       href="http://www.aps.anl.gov/epics/">Experimental Physics and Industrial
      Control System</a>.</p>


      <h2 class="nocount">Status of this Document</h2>
      <!-- Statement about why this version exists -->

      <p>This is the 27 May 2012 version of the Normative Types document. This
      version adds meta data and self identification, and Appendix of items likely
      to be added in future drafts.</p>

      <p class="ed">TODO: Add version number in meta. Each optional field of each
      Normative type, where the option field is not in the Standard Optional Fields
      (as so whose semantics are deliberately not defined), must be defined within
      the normative type. Ie, find all display and control, and define what they
      mean. </p>
      
      <p>See <a href="#appendix_a:_possible_future_additions_to_this_specification">
      Appendix A</a> for items that may be added to future revisions of this
      specification. </p>

      <p> This version is an Editors Draft towards the First Public Working
      Draft. The First Public Working Draft will be intended for the EPICS community
      to review and comment. Resulting comments will drive subsequent revisions of
      the Normative Types specification and the EPICS V4 Working Group's reference
      implementations of software that helps create, populate and exchange Normative
      Type PVData.  </p>

      <p> Comments are welcome, though bear in mind this is a pre-public release
      version. </p>

      <p>The terms MUST, MUST NOT, SHOULD, SHOULD NOT, REQUIRED, and MAY when
      highlighted (through style sheets, and in uppercase in the source) are used in
      accordance with RFC 2119 [RFC2119]. The term NOT REQUIRED (not defined in RFC
      2119) indicates exemption. </p>

</div> <!-- head -->

<div id="toc">
  <h2 class="nocount" style="page-break-before: always">Table of Contents</h2>
</div>

<div id="contents" class="contents">	  
<hr />
<h2 id="introduction">Introduction</h2>

<p>The Normative Types described in this document are a set of software designs for high
  level <a href="http://en.wikipedia.org/wiki/Data_type#Composite_types" >composite data
types</a> suitable for the application level data exchange between EPICS V4 network endpoints. In
particular, they are intended for use in online scientific instrument
operations. The intention is that where the endpoints in an EPICS V4 network all use only 
Normative Types, each peer in the network should be able to understand all the data
transmitted to it, at least syntactically, and be able to take processing
steps appropriate to that data.</p>

<p>The EPICS version 4 module PVData <a class="bib" href="#bib:pvdata">bib:pvdata</a> supplies
a typing mechanism and object management API for efficiently defining, creating,
accessing and updating memory resident structured data. EPICS V4 module PVAccess <a class="bib"
 href="#bib:pvaccess">bib:pvaccess</a> supports the efficient exchange of PVData
defined data between EPICS V4 network peers. EPICS V4 Normative Types, defines some
general purpose data types, that build on the PVData. These are designed to be
generally applicable to controls and the application level of scientific
instruments. </p>

<p>The simplest example is the Normative Type "NTScalar". When a client receives a
PVData datum which identifies itself as being of type NTScalar, the client will know
to expect the scalar's value will be accompanied by an indication of alarm severity
and a timestamp (see example below).</p>

<p>An example of a simple normative type is the NTScalar:</p>
<pre>structure NTScalar
  <span class="nterm">time_t</span>     timeStamp
  <span class="nterm">alarm_t</span>    alarm
  double     value
</pre>
<p>

A more complex example; if a client receives a PVData datum which identifies itself as being
of type NTTable, this document specifies that it should expect the datum to contain 0 or more
arrays of different types. The definition of NTTable below will say that the client
should interpret the arrays as the columns of a table,
and should render appropriately as a table, with rows being the same numbered elements of
each array. 
</p>
<pre>structure NTTable
  string[]    labels          // Very short text describing each field below, i.e. column labels
  {<span class="nterm">scalar_t</span>[] <span class="user">colname</span>}<sub>0+</sub>    // 0 or more scalar array type instances, the columns.<span class="opt">
  string      descriptor    : opt
  <span class="nterm">alarm_t</span>     alarm         : opt
  <span class="nterm">time_t</span> timeStamp          : opt</span>
</pre>

<p>A Normative Type can be used both for sending data from client to service
and from service to client. In this document we refer generally to an
<em>agent</em>, being either a client or a server. If the agent is specifically at
the user's end, we call it the <em>user agent</em>. <em>Client</em> and
<em>server</em> refer to the directionality of the transaction, server being the
agent that is doing the sending.</p>


<h2 id="metalang">Description of Normative Types</h2>

<p>All the EPICS V4 Normative Types are defined as particular structure instance
definitions of a PVData <a href="http://epics-pvdata.hg.sourceforge.net/hgweb/epics-pvdata/pvDataJava/raw-file/tip/documentation/pvDataJava.html#L184" >structure</a>. This is true even of the Normative Types describing
simple values like a single int, since a given Normative Type defined datum may
include alarm or timestamp. Hence, all Normative Types are structures. The fields of
a given Ntype then, can be ascertained at runtime by the <a
 href="http://epics-pvdata.sourceforge.net/docbuild/pvDataJava/1.0-BETA/documentation/pvDataJava.html#L485">
pvData Field introspection interface</a> <a class="bib" href="#bib:pvdata">bib:pvdata</a>.</p>


<p><span style="font-weight:bold;">Definition</span>: Normative Type</p>
<p>The Normative Types defined in this document each have the following general form:</p>
<ol>
  <li>Is defined as a structure and implemented specifically as a pvData Structure</li>
  <li>The pvData structure instance self-identifies as a Normative Type of one
  of the kinds below. At the time of writing, the fieldName of the Structure itself
  is used as the mechanism by which the instance self-identifies as a datum of Normative
  Type, but this may change in future revisions of this specification</li>
  <li>The fields of the Structure are all from the set of<a href="#L177"> Normative
  Type Fields</a> below</li>
  <li>There are 1 or more fields of the structure</li>
</ol>

<h3>Syntax and Grammar Conventions</h3>

<p>The Normative Type data descriptions are given with the syntactic
conventions and grammar given below. This is a hybrid of the <a
href="http://epics-pvdata.sourceforge.net/docbuild/pvDataJava/1.0-BETA/documentation/pvDataJava.html#L163">pvData
"Meta" Language</a> and BNF, in order to add clear distinctions between symbol types,
particularly terminality, recurrence, which names a user is expected to add and which
are predefined.</p>

<p><span class="nterm">italics</span> - a non-terminal. Used to stand for a choice of
pvData type, or named sequence of fields, or for fields that are themselves defined
as structures, and hence non-terminal. In implementation the latter will have
pvData field Type <a
 href="http://epics-pvdata.sourceforge.net/docbuild/pvDataJava/1.0-BETA/documentation/pvDataJava.html#L411">structure</a></p>

<p><span class="term">plaintext</span> - terminals, either a terminal pvData type
name or a label. In the case of terminal pvData type, in implementation these will be
instances of pvData Field types <a
 href="http://epics-pvdata.sourceforge.net/docbuild/pvDataJava/1.0-BETA/documentation/pvDataJava.html#L411">scalar
or scalarArray</a>, eg <span class="term">double</span> or <span class="term">int
[]</span>.</p>

<p><span class="user">name</span> - A user provided label name. This is a kind of
terminal. A programmer using the Normative Type will choose what goes in the &lt;&gt;.</p>

<p>&#123; &#125; - a sequence of occurrences of the item or items in the braces. The
number of occurrences is given in the following subscript, 0+ means 0 or more, 1+ means
1 or more.</p>

<p>The grammar for a normative type definition follows the pattern
below. That is, a Normative Type is defined as a structure composed of fields. A
field may be optional, and may be described along with a comment:</p>

<pre>structure <span class="term">NTname</span>
   { ( <span class="nterm">ntfield</span> fieldName [:opt] [// comment text] ) }<sub>1+</sub>
</pre>
<p>where:</p> 
<dl>
  <dt><span class="term">NTname</span></dt>
    <dd>The name of the Normative Type</dd>
  <dt><span class="nterm">ntfield</span></dt>
    <dd>One of the valid <a href="#normative_type_fields">Normative Type Fields</a> as defined below</dd>
  <dt>fieldName</dt>
    <dd>The identifier of the field. Where the field is a terminal in the grammar
   (ie, does not have  &lt;&gt; around its name) then the fieldName is a PVData Field
   name, as returned by a call to getFieldName() on the Field member object. <span class="ed">must add
   reference to Field, getFieldName when this interface is settled?</span></dd>
   <dt>:opt</dt>
    <dd>Indicates that the preceding field is optional in the normative type</dd>
      <dt>// <span class="term">comment text</span></dt>
      <dd>A field production element may be followed by a comment </dd>
</dl>


<h2>Normative Type Fields</h2>

<p>This section defines the fields that may appear in a Normative Type's
definition.</p>

<p>Each field of a normative type (  <span class="nterm">ntfield_t</span> ) will be
one of the following: </p>

<pre>
<span class="nterm">ntfield</span> := 

  <span class="nterm">scalar_t</span>        // a simple numerical, boolean, or string value
| <span class="nterm">scalar_t[]</span>      // an array of simple values
| <span class="nterm">enum_t</span>          // an enumeration
| <span class="nterm">enum_t[]</span>        // an array of enumerations 
| <span class="nterm">time_t</span>          // a point in time, used for timestamps
| <span class="nterm">time_t[]</span>        // an array of points in time
| <span class="nterm">alarm_t</span>         // a summary diagnostic of a control system event
| <span class="nterm">alarm_t[]</span>       // an array of summary diagnostics
| <span class="nterm">alarmlimit_t</span>    // value thresholds for a control system diagnostic report
| <span class="nterm">alarmlimit_t[]</span>  // an array of threshold values
| <span class="nterm">display_t</span>       // meta data of displayed data
| <span class="nterm">display_t[]</span>     // an array of display mata data
| <span class="nterm">control_t</span>       // control setpoint range boundaries 
| <span class="nterm">control_t[]</span>     // an array of control setpoint range boundaries 
</pre>

<h3>Simple Normative Type Fields - scalar types</h3>

<p>Note that of all the Normative Type fields only <span class="nterm">scalar_t</span> is of simple type,
that is, having a single or array value. All the others are represented by a
structure (see <a href="#structuredNormativeFields">Structure Normative
Fields</a> below). </p>

<h4>scalar_t</h4>

<p>The field is a scalar value. Scalar fields would be implemented with PVData field
  Type <a href="http://epics-pvdata.sourceforge.net/docbuild/pvDataJava/1.0-BETA/documentation/pvDataJava.html#L485" >"scalar"</a>:</p>
<pre>
<span class="nterm">scalar_t</span> :=

   boolean  // true or false 
|  byte     // 8 bit signed integer 
|  short    // 16 bit signed integer 
|  int      // 32 bit signed integer 
|  long     // 64 bit signed integer 
|  float    // single precision IEEE 754 
|  double   // double precision IEEE 754
|  string   // UTF-8 *
</pre>

<h4>scalar_t[]</h4>

<p>The field is an array of scalars. Scalar array fields would be implemented with PVData field
  Type <a href="http://epics-pvdata.sourceforge.net/docbuild/pvDataJava/1.0-BETA/documentation/pvDataJava.html#L485" >"scalarArray"</a>:</p>

<pre>
<span class="nterm">scalar_t[]</span> :=

   boolean[]  // array of true or false
|  byte[]     // array of 8 bit signed integer
|  short[]    // array of 16 bit signed integer
|  int[]      // array of 32 bit signed integer
|  long[]     // array of 64 bit signed integer
|  float[]    // array of single precision IEEE 754
|  double[]   // array of double precision IEEE 754
|  string[]   // array of UTF-8 *</pre>

<h3 id="L269">Structured Normative Fields</h3>

<p>This subsection defines those fields of a Normative Type structure definition,
 that are themselves structures or arrays of structures.</p>

<p>The structured normative fields would be implemented with type PVData field Type <a
href="http://epics-pvdata.sourceforge.net/docbuild/pvDataJava/1.0-BETA/documentation/pvDataJava.html#L485"
>"structure"</a> or <a
href="http://epics-pvdata.sourceforge.net/docbuild/pvDataJava/1.0-BETA/documentation/pvDataJava.html#L485"
>"structureArray"</a>.</p>

<h4>enum_t</h4>

<p>An <span class="nterm">enum_t[]</span> describes an enumeration. The field is a
  structure describing a value drawn from a given set of valid values also given. It
  is implemented as a pvData Field of Type <a
   href="http://epics-pvdata.sourceforge.net/docbuild/pvDataJava/1.0-BETA/documentation/pvDataJava.html#L485"
   >"structure"</a> with the following form:</p>

<pre>
<span class="nterm">enum_t</span> :=

structure enum 
    int index
    string[] choices
</pre>

<p>where:</p>
<dl>
  <dt>aname</dt>
    <dd>The name of the structure can be any valid name.</dd>
  <dt>index</dt>
    <dd>The index of the current value of the enumeration in the array
      choices below</dd>
  <dt>choices</dt>
    <dd>An array of strings specifying the set of labels for the valid values
      of the enumeration.</dd>
</dl>

<h4>enum_t[]</h4>

<p>An <span class="nterm">enum_t[]</span> describes an array of enumerations. The
  field is an array of structures each describing a value drawn from a given set of
  valid values also given in each. It is implemented as a PVData field of Type <a
   href="http://epics-pvdata.sourceforge.net/docbuild/pvDataJava/1.0-BETA/documentation/pvDataJava.html#L485"
   >"structureArray"</a> each element of which with the form of <span
  class="nterm">enum_t</span> above.</p>


<h4>time_t</h4>

<p>A <span class="nterm">time_t</span> describes a defined point in time. The field is a structure describing a time relative to
midnight on January 1st, 1970 UTC. It is implemented as a pvData field of Type
<a href="http://epics-pvdata.sourceforge.net/docbuild/pvDataJava/1.0-BETA/documentation/pvDataJava.html#L485" >"structure"</a> with the following form: </p>

<pre>
<span class="nterm">time_t</span> :=

structure timeStamp
   long secsPastEpoch   
   int  nanoseconds
   int  userTag</pre>

<p>where:</p>
<dl>
  <dt>secsPastEpoch</dt>
    <dd>Seconds since Jan 1, 1970 00:00:00 UTC</dd>
  <dt>nanoSeconds</dt>
    <dd>Nano seconds relative to the <span class="term">secsPastEpoch</span> field</dd>
  <dt>userTag</dt>
    <dd>An integer value whose interpretation is deliberately undefined and therefore MAY be
      used by EPICS V4 agents in a user defined way</dd>
</dl>

<p>Interpretation: The point in time being identified by a <span
class="nterm">time_t</span>, is given by Jan 1, 1970 00:00:00 UTC plus some
nanoseconds given by its <span class="term">secsPastEpoch</span>
times 10<sup>9</sup> plus its <span class="term">nanoseconds</span>.</p>

<p>pvData provides two helper classes for a timeStamp structure: timeStamp, and
PVTimeStamp.</p>

<h4>time_t[]</h4>

<p>A <span class="nterm">time_t[]</span> describes an array of points in time. The
 field is an array of structures each describing a time relative to January 1st, 1970
 UTC. It is implemented as a PVData field of Type <a
  href="http://epics-pvdata.sourceforge.net/docbuild/pvDataJava/1.0-BETA/documentation/pvDataJava.html#L485"
  >"structureArray"</a> each element of which with the form of <span
 class="nterm">time_t</span> above.</p>


<h4>alarm_t</h4>

<p>An <span class="nterm">alarm_t</span> describes a diagnostic of the value of a
control system process variable. It indicates essentially whether the associated value is good or
bad, and whether agent systems should alert people to the status of the
process.</p>

<p> Processes in EPICS V3 and V4 IOCs include extensive support for evaluating
alarm conditions. The definition of the fields in an <span class="term">alarm</span>
are given in <a class="bib" href="#bib:epicsrecref">bib:epicsrecref</a>.  The field is a
structure describing an alarm. It is implemented as a PVData field of Type
<a
 href="http://epics-pvdata.sourceforge.net/docbuild/pvDataJava/1.0-BETA/documentation/pvDataJava.html#L485"
 >"structure"</a> with the following form: </p>

<pre>
<span class="nterm">alarm_t</span> :=

structure alarm
   int severity
   int status
   string message
</pre>

<p>where:</p>
<dl>
  <dt>severity</dt>
      <dd>severity is defined as an int (not an <span class="nterm">enum_t</span>), but
      MUST be functionally interpreted as the enumeration
	{noAlarm, minorAlarm, majorAlarm, invalidAlarm, undefinedAlarm } indexed from
	noAlarm=0</dd>
  <dt>status</dt>
      <dd>status is defined as an int (not an <span class="nterm">enum_t</span>), but
      MUST be functionally interpreted as the enumeration {noStatus, deviceStatus,
	driverStatus, recordStatus,
    dbStatus, confStatus, undefinedStatus, clientStatus } indexed from noStatus=0.</dd>
  <dt>message</dt>
    <dd>A message string.</dd>
</dl>

<p>Interpretation MUST be as with V3 IOC record processing, as described in the <a
class="bib" href="#bib:epicsrecref">epicsrecref</a>.</p>
<p>pvData provides two helper classes for an alarm structure: alarm, and
PVAlarm.</p>

<h4>alarm_t[]</h4>

<p>An <span class="nterm">alarm_t[]</span> is an array of alarm conditions. The field
is an array of structures each describing an alarm condition. It is implemented as a
PVData field of Type <a
 href="http://epics-pvdata.sourceforge.net/docbuild/pvDataJava/1.0-BETA/documentation/pvDataJava.html#L485"
 >"structureArray"</a> each element of which with the form of <span
class="nterm">alarm_t</span> above.</p>


<h4>alarmlimit_t</h4>


<p>An <span class="nterm">alarmlimit_t</span> is a structure that gives the numeric
  intervals to be used for the high and low limit ranges of an associated limit type
  alarm. The specific instance of the alarm to which the alarmlimit refers, is not
  specified in the alarmlimit structure, it may be any EPICS alarm.  
<span
class="nterm">alarmlimit_t</span> is implemented as a PVData field of Type <a
 href="http://epics-pvdata.sourceforge.net/docbuild/pvDataJava/1.0-BETA/documentation/pvDataJava.html#L485"
 >"structure"</a> with the following form: </p>


<pre><span class="nterm">alarmlimit_t</span> :=

structure alarmlimit
    double highalarm
    double highwarning
    double lowwarning
    double lowalarm
 </pre>

<p>where:</p>
<dl>
  <dt>alarmlimit</dt>
    <dd>The structure must have the name "alarmlimit".</dd>
  <dt>highalarm</dt>
    <dd>Upper bound of allowed operating range of the value to which the alarmlimit refers</dd>
  <dt>highwarning</dt>
    <dd>Upper bound of normal operating range of the value to which the alarmlimit refers</dd>
  <dt>lowwarning</dt>
    <dd>Lower bound of normal operating range of the value to which the alarmlimit refers</dd>
  <dt>lowalarm</dt>
    <dd>Lower bound of allowed operating range of the value to which the alarmlimit refers.</dd>
</dl>

<p>The interpretation is that where the Normative Type instance's value field is:
<ul>

  <li> outside the closed interval [lowwarning,highwarning] the value SHOULD be
  considered out of its <em>normal</em> operating range</li>

  <li> outside the closed interval [lowalarm,highalarm], the value SHOULD be
  considered out of its <em>allowed</em> operating range</li>

 <li> neither inside (lowwarning,highwarning) nor outside [lowalarm,highalarm] then
 the value SHOULD be considered out of its normal operating range but is still inside
 its allowed range.</li>

</ul>

<p>Since the above conditions do not at all form a three valued function over all
possible values of the limits, the invariant <em>lowalarm <= lowwarning <=
highwarning <= highalarm</em> SHOULD be observed when setting the those thresholds.</p>

<p>Code in both V3 IOC record support and in V4 IOC  
raises alarms based on how the alarm limits are valued according to the following
algorithm:</p>
<pre>
If the value is >= highalarm then a major alarm is raised
else if value>=highwarning then a minor alarm is raised
else if value<= lowalarm then a major alarm is issued
else if value<=lowwarning then a minor alarm is raised
else do not raise an alarm.
</pre>

<p>Where an <span class="nterm">alarmlimit_t</span> structure instance is present
in a Normative Type structure, it MUST be interpreted as referring to that
Normative Type's field named "value". Therefore it is only used in Normative Types
that have a single numeric "value" field.</p>

<h4>alarmlimit_t[]</h4>

<p>An alarmlimit_t[] is an array of alarm limit conditions. The field is an array of
structures each describing an alarm limit. It is implemented as a PVData field of
Type <a
 href="http://epics-pvdata.sourceforge.net/docbuild/pvDataJava/1.0-BETA/documentation/pvDataJava.html#L485"
 >"structureArray"</a> each element of which with the form of <span
class="nterm">alarmlimit_t</span> above.</p>


<h4>display_t</h4>

<p>A <span class="nterm">display_t</span> is a structure that describes some typical attributes of
a numerical value that are of interest when displaying the value on a computer screen
or similar medium. The <span class="term">units</span> field SHOULD contain a string representation of the
physical units for the value, if any. The <span class="term">description</span> field SHOULD contain a
short (one-line) description of what the value represents, such as can be
used as a label in a display. The fields <span class="term">lowlimit</span>
and <span class="term">highlimit</span> represent the
range in between which the value should be presented as adjustable.
</p>
<p>
The field is a structure describing a <span class="nterm">display_t</span>. It is implemented as a PVData field of Type
<a
href="http://epics-pvdata.sourceforge.net/docbuild/pvDataJava/1.0-BETA/documentation/pvDataJava.html#L485"
>"structure"</a> with the following form: </p>

<pre><span class="nterm">display_t</span> :=

structure display
    double lowlimit
    double highlimit
    string description
    string format
    string units
 </pre>

<p>where:</p>
<dl>
  <dt>display</dt>
    <dd>The structure must have the name "display". </dd>
  <dt>lowlimit</dt>
    <dd>The lower bound of range within which the value must be set, to be presented to a user </dd>
      <dt>highlimit</dt>
    <dd>The upper bound of range within which the value must be set, to be presented to a user </dd>
  <dt>description</dt>
    <dd>A textual summary of the variable that the value quantifies</dd>
  <dt>format</dt>
    <dd>A format for converting the value field to a string <span class="ed">Needs
      work: What is display.format? What's it for and what are examples? If it's a sprintf pattern, which syntax must
it conform to - C or Java? </span></dd>
  <dt>units</dt>
    <dd>The units for the value field.</dd>
</dl>

<p>Where an <span class="nterm">display_t</span> structure instance is present
in a Normative Type structure, it MUST be interpreted as referring to that
Normative Type's field named "value". Therefore it is only used in Normative Types
that have a single numeric "value" field.</p>

<h4>display_t[]</h4>

<p>A display_t[] is an array of <span class="nterm">display_t</span>. The field is an array of
structures each describing the display media oriented metadata of some corresponding
process variable value, as described by <span class="nterm">display_t</span> above. It is implemented as a PVData field of
Type <a
 href="http://epics-pvdata.sourceforge.net/docbuild/pvDataJava/1.0-BETA/documentation/pvDataJava.html#L485"
 >"structureArray"</a> each element of which with the form of <span
class="nterm">display_t</span> above.</p>


<h4>control_t</h4>
<p>An <span class="nterm">control_t</span> is a structure that describes a range,
given by the interval
(limitlow,limithigh), within which it is expected some control software or hardware
shall bind the control PV to which this Normative Type
instance's value field refers.</p>
<p>
The field is a structure describing a <span class="nterm">control_t</span>. It is implemented as a PVData field of
Type <a
 href="http://epics-pvdata.sourceforge.net/docbuild/pvDataJava/1.0-BETA/documentation/pvDataJava.html#L485"
 >"structure"</a> with the following form: </p>

<pre><span class="nterm">control_t</span> :=

structure control
        double lowlimit
        double highlimit</pre>

<p>where:</p>
<dl>
  <dt>control</dt>
    <dd>The structure must have the name "control"
      array.</dd>
  <dt>lowlimit</dt>
    <dd>The control low limit for the value field</dd>
      <dt>highlimit</dt>
    <dd>The control high limit for the value field.</dd>
</dl>

<h4>control_t[]</h4>

<p>A control_t[] is an array of <span class="nterm">control_t</span>. The field is an
array of structures each describing the setpoint range interval of some process variable. It is
implemented as a PVData field of Type <a
 href="http://epics-pvdata.sourceforge.net/docbuild/pvDataJava/1.0-BETA/documentation/pvDataJava.html#L485"
 >"structureArray"</a> each element of which with the form of <span
class="nterm">control_t</span> above.</p>



<h2>Normative Type Meta Data</h2>

<p>Meta data are included in runtime instances of Normative Types. The meta data
includes to which Normative Type the structure instance conforms, version
information, and other data to aid efficient processing, diagnostics and
displays.</p>

<h3>Self Identification</h3>

<p>Each runtime instance of a normative type MUST include exactly one structure type Field,
named _META, defined below, that says to which Normative Type the instance conforms,
together with other descriptive data about the instance. Agents can use this meta
data to check the received type was as expected. </p>

<p><span class="nterm">meta_t</span> describes a structure, named _META, whose fields define meta
data of the Normative Type instance in which the _META was included. </p>

<pre><span class="nterm">meta_t</span> :=

structure _META
        boolean <span class="user">NTName</span>    
        boolean hasAlarm
        boolean hasDescriptor
        boolean hasTimeStamp</pre>

<p>where:</p>
<dl>
  <dt><span class="user">NTName</span></dt>
    <dd>Is the name of the Normative Type in section 5 below. That is, the name of
      the first field of _META MUST be a boolean, and its field name MUST be the name
      of the normative type to which the structure containing _META conforms. NOTE
      that the value of the boolean so named, is not important. </dd>
  <dt>hasDescriptor</dt>
    <dd>A boolean value that describes whether the Normative Type instance contains a
      descriptor field. </dd>
  <dt>hasAlarmM</dt>
    <dd>A boolean value that describes whether the Normative Type instance contains an
      alarm field. </dd>
  <dt>hasTimeStamp</dt>
    <dd>A boolean value that describes whether the Normative Type instance contains a
      timeStamp field. </dd>
</dl>
<p><span
      class="nonnorm">The reason for the somewhat curious identification mechanism
      is so that the Normative Type of a structure can be communicated in the
introspection data, and so need not be exchanged with every instance exchange.</span></p>

<h3>Standard optional meta data fields</h3>

<p>One instance of each of the following fields may be included in a Normative Type
instance structure. There is no required interpretation of these fields, and therefore their meaning
is not further described in the Normative Type definitions below.</p>

<p>An object of Normative Type may optionally include a field
named "descriptor" and of type string, to be used to give identity, name, or sense
information. For instance, it may be valued with the name of a device associated with control data, or
the run number of a table of model data.</p>
<pre>
string descriptor  :opt     // Contextual information 
</pre>

<p>An object of Normative Type may optionally include an alarm field. </p>
<pre>
<span class="nterm">alarm_t</span> alarm      :opt     // Control system event summary
</pre>

<p>An object of Normative Type may optionally include a timeStamp
field. </p>
<pre>
<span class="nterm">time_t</span> timeStamp   :opt     // Event time
</pre>


<h2>General Normative Types</h2>

<p>The General Normative Types are for encapsulating data of any kind of
application or use case. Compare to <a href="#specificnormativetypes ">Specific
Normative Types</a> defined later in this document, and which are oriented to
particular use cases.</p>

<h3>NTScalar</h3>

<p>NTScalar is an EPICS V4 Normative Type that describes a single scalar value plus metadata:</p>
<pre>structure  NTScalar
    <span class="nterm">scalar_t</span>    value<span class="opt">
    string      descriptor  :opt 
    <span class="nterm">time_t</span>      timeStamp   :opt
    <span class="nterm">alarm_t</span>     alarm       :opt
    <span class="nterm">display_t</span>   display     :opt
    <span class="nterm">control_t</span>   control     :opt</span>
</pre>

<p>where:</p>
<dl>
  <dt>value</dt>
    <dd>The primary data carried by the NTScalar object. The field must be named
      "value" and can be of any simple scalar type as defined above.</dd>
</dl>

<h3>NTEnum</h3>

<p>NTEnum is an EPICS V4 Normative Type that describes an enumeration (a closed set
of possible values each described by an n-tuple).</p>

<pre>structure NTEnum
    <span class="nterm">enum_t</span>      value
    string[]    longdescriptions         :opt<span class="opt">
    string      descriptor  :opt
    <span class="nterm">time_t</span>      timeStamp   :opt
    <span class="nterm">alarm_t</span>     alarm       :opt</span>
</pre>
 
<p>where:</p>
<dl>
  <dt>value</dt>
    <dd>The primary data carried by the NTEnum object. The field must be named
      "value" and must be an enumeration as defined above.
    </dd>
  <dt>longdescriptions</dt>
    <dd>Text which may be used to add context and information for each choice, such
      as may be used in displays. If given, longdescriptions MUST be an array of
      strings of length equal to <span class="term">values.choices</span>. Each 
      element of the array SHOULD describe the ordinally corresponding
      <span class="term">values.choices</span> element. For instance, if the NTEnum's <span class="term">value.index</span> is valued 1,
      and longdescriptions is given, then longdescriptions[1] MUST contain a string meaningfully
      describing <span class="term">value.choice[1]</span>.
    </dd>
 </dl>

<h3>NTMatrix</h3>

<p>NTMatrix is an EPICS V4 Normative Type used to define a matrix, specifically a
 2-dimensional array of real numbers.</p>
 
<pre>structure NTMatrix
    double[]  value
    int[2]       dim         :opt<span class="opt">
    string      descriptor  :opt
    <span class="nterm">time_t</span>      timeStamp   :opt
    <span class="nterm">alarm_t</span>     alarm       :opt
    <span class="nterm">display_t</span>   display     :opt</span>
</pre>


<p>where:</p>
<dl>
  
  <dt>value</dt>
    <dd>The numerical data comprising the matrix. The value is given as a single
    array of doubles.</dd>
    
  <dt>dim</dt>
    <dd>

      <span class="term">dim</span> indicates the dimensions of the matrix. If <span
      class="term">dim</span> is not present, <span class="term">value</span> MUST be
      interpreted as a vector, of length equal to the number of elements of <span
      class="term">value</span>. If <span class="term">dim</span> is present, then it
      must have 1 or 2 elements; its one element value or both elements values MUST
      be > 0, and the number of elements in <span class="term">value</span> MUST be
      equal to the product of the elements of <span class="term">dim</span>. If <span
      class="term">dim</span> is present and contains a single element, then the
      NTMatrix MUST be interpreted as describing a vector. A <span
      class="term">dim</span> of 2 elements describes a matrix, where the first
      element of <span class="term">dim</span> gives the number of rows, and the
      second element of <span class="term">dim</span> gives the number columns. If
      <span class="term">dim</span> is present and contains 2 elements, of which the
      first is unity, and the second is not (therefore must be >1) then the NTMatrix
      MUST be interpreted as describing a row vector. If <span
      class="term">dim</span> is present as contains 2 elements, of which the second
      is unity, and the first is not (therefore must be >1) then the NTMatrix MUST be
      interpreted as describing a column vector.
      
    </dd>
</dl>

<p>User agents that print or otherwise render an NTMarix SHOULD print row vector,
column vector, and non-vector matrices appropriately.</p>

<p class="nonnorm">Presently, Normative Types are intended only to specify
interoperable data types of PVAccess data exchanges of PVData. As such, all data
manipulation of the values in a PVData datum are through the methods of
PVStructure. Since Normative Types do not specify agent implementation details, the
layout of an NTMatrix's value array data in memory is not defined, and should not be
expected to be reliably dependent on the language interface. For instance, expecting
row-major order in memory when using the C binding, or column-major at other times
(Fortran, Matlab), would not be sensible.</p>
      

<h3>NTVariantArray</h3>

<p>NTVariantArray is an EPICS V4 Normative Type to define a single structure which
contains an number of arrays, each of different type, but where the value of the
NTVariantArray as a whole is taken to be the value of only one of the arrays at a
time. In that way, it can be used to encode data in arrays whose type may be changed
according to runtime conditions and the data to be expressed.</p>

<p> NTVariantArray is defined with arrays of each pvData scalar type. At any
particular time its value MUST be interpreted to be only one of these arrays. The
<code>dataType</code> member specifies which array MUST be taken to be the
NTVariantArray's type. The data arrays need not be all the same length. Arrays other
than that presently selected by <code>dataType</code> MAY be populated; in this way
<code>dataType</code> can be used as a value selector.</p> <p>

</p>
<pre>structure NTVariantArray
    int dataType                  // Identifies which scalar array defines the present value
    boolean [] booleanValue       // Defines the NTVariantArray's value if dataType == 0
    byte [] byteValue             // Defines the NTVariantArray's value if dataType == 1 
    short [] shortValue           // Defines the NTVariantArray's value if dataType == 2
    int [] intValue               // Defines the NTVariantArray's value if dataType == 3
    long [] longValue             // Defines the NTVariantArray's value if dataType == 4
    float [] floatValue           // Defines the NTVariantArray's value if dataType == 5
    double [] doubleValue         // Defines the NTVariantArray's value if dataType == 6
    string [] stringValue         // Defines the NTVariantArray's value if dataType == 7
    <span class="nterm">timestamp_t[]</span> timeStampValue  // Defines the NTVariantArray's value if dataType == 8
    <span class="nterm">alarm_t</span> [] alarmValue         // Defines the NTVariantArray's value if dataType == 9<span class="opt">
    string      descriptor  :opt
    <span class="nterm">time_t</span>      timeStamp   :opt
    <span class="nterm">alarm_t</span>     alarm       :opt
    <span class="nterm">display_t</span>   display     :opt</span> 
</pre>

<p>where:</p>
<dl>
  <dt>dataType</dt>
  <dd>This defines that data type for the column. It is one of: 
      <pre>
0 - booleanValue
1 - byteValue
2 - shortValue
3 - intValue
4 - longValue
5 - floatValue
6 - doubleValue
7 - stringValue
8 - timeStampValue
9 - alarmValue
       </pre>
  </dd>
  <dt>booleanValue,...,alarmValue</dt>
    <dd>The arrays that may be used to hold data. The array indicated by <span
      class="term">dataType</span>is that one which defines the NTVariantArray's value.</dd>
</dl>

<h3>NTNameValue</h3>

<p>NTNameValue is an EPICS V4 Normative Type that describes a system of name and
scalar values. </p>


<p> For the related problem of expressing a key-value system where each value may be
array valued, see <a href="#ntvariantarray">NTVariantArray</a> or <A href="#nttable">NTTable</a>.</p>

<p>Use cases: In a school, a single NTNamedValue might describe the grades from a
 number of classes for for one student. </p>

<pre>structure NTNameValue
   string[]          name
   <span class="nterm">scalar_t[]</span>        value   <span class="opt">
   string            descriptor :opt
   <span class="nterm">time_t</span>            timeStamp  :opt
   <span class="nterm">alarm_t</span>           alarm      :opt</span>
</pre>

<p>where:</p>
<dl>
  <dt>name</dt>
    <dd>The keys associated with the  <span class="term">value</span> field. Each
      element of <span class="term">name</span>  identifies the
      same indexed element of the <span class="term">value</span> field, using a string label. </dd>
  <dt>value</dt>
    <dd>The data values, each element of which is associated with the correspondingly
      indexed element of the  <span class="term">name</span> field.</dd>
</dl>

<p>Each name (or "key") in the array of names, MUST be interpreted as being associated with its same
indexed element of the <span class="term">value</span> array. </p>


<h3>NTTable</h3>

<p>NTTable is the EPICS V4 Normative Type for "2-d" tabular datasets.</p>

<p>An NTTable is made up of a number of arrays, each array being of a scalar type. Each array
can be thought of as a column. Each <em>i</em>th array member makes up one row, or n-tuple.</p>

<p>Use case examples: a table of twiss paramaters of all
lattice elements in an accelerator section. Another example, where the columns
might vary call-to-call would be that of an EPICS V4 SQL database service. In that example
one NTTable returned by the service would contain all the tabular results of a SQL SELECT,
essentially a recoded JDBC or ODBC ResultSet - see the <a class="bib"
href="#bib:rdbservice">rdbservice</a>.
</p>

<pre>structure NTTable
  string[]    labels          // Very short text describing each field below, i.e. column labels
  {<span class="nterm">scalar_t</span>[] <span class="user">colname</span>}<sub>0+</sub>    // 0 or more scalar array type instances, the columns.<span class="opt">
  string      descriptor    : opt
  <span class="nterm">alarm_t</span>     alarm         : opt
  <span class="nterm">time_t</span> timeStamp          : opt</span>
</pre>

<p>where:</p>
<dl>
  <dt>labels</dt>
    <dd>The table column headings of each column, each heading given as one element
      of the array of strings. The order of labels matches the order of the
      <span class="nterm">scalar_t</span>[] data.
    </dd>
</dl>

<h4>Interpretation</h4>

<p>This represents a table. The number of "columns" is equal to the number of fields
which follows field "labels." Each <span class="user">colname</span>[] field has the
data for its "column."  The value of each element of <span class="term">labels</span>
SHOULD be used as a column heading for the corresponding <span
class="user">colname</span> field.</p>

<p>Note that the above description is given in terms of a table and its columns,
but there is nothing specifically columnar about how this data may be rendered. A
user may choose to print the fields row wise. For instance, if there are many fields,
but each has only length 1 or 2. E.g., if you wanted to give all the scalar data related
to one device, then you might use an NTTable rendered in such a way. Note that one column
of a table would also be easily described by NTNameValue.
</p>

<h4>Validation</h4>

<p>The number of <span class="nterm">scalar_t</span> fields and the length of labels MUST be the same. All
<span class="nterm">scalar_t</span> fields MUST have the same length, being the number of "rows" in the
table.</p>


<h2>Specific Normative Types</h2>


<p>The "specific normative types" below are types oriented towards application level
scientific and engineering use cases. Compare to <a
href="#specificnormativetypes">General Normative Types</a> defined above. The
currently defined types are each described in a section below.</p>

<p>Unless otherwise stated:</p>
<ul>
  <li>Times MUST be in seconds</li>
  <li>Frequencies MUST be in Hz.</li>
</ul>


<h3>NTMultichannelArray</h3>

<p>MultichannelArray is an EPICS V4 Normative Type that aggregates an array of scalar
values from different EPICS Process Variable (PV) channel sources, into a single variable. </p>

<p>Use cases; in a particle accelerator, a single NTMultichannelArray might include
the data of a number of Beam Positon Monitors' X offset values, or of a number of
quadrupoles' desired field values. </p>

<pre>structure NTMultichannelArray
  <span class="nterm">scalar_t</span>[]  value               // The channel values
  string[]    PVnames             // Process Variable names
  <span class="nterm">time_t</span>      timeStamp           // Base value time stamp 
  int[]       severities     :opt // Alarm severity associated with each value
  double[]    positions      :opt // The position of each value element
  double[]    deltaTimes     :opt // The time relative to the timeStamp, in seconds<span class="opt"> 
  string      descriptor     :opt
  <span class="nterm">alarm_t</span>     alarm          :opt</span>
</pre>

<p>where:</p>
<dl>
  <dt>value</dt>
    <dd>The array of values of the EPICS Process Variables</dd>
  <dt>PVnames</dt>
      <dd>The names of each of the EPICS Process Variables that sourced each of
	corresponding element of the <span class="term">value</span> field</dd>
	<dt>timeStamp</dt>
	<dd>The base time stamp associated with values as a whole. See also <span
	  class="term">deltaTimes</span> field
	</dd>
  <dt>severities</dt>
    <dd>The EPICS alarm severity associated with each value</dd>
  <dt>positions</dt>
    <dd>A location (such as Z or S position) or cardinal value associated with each
      element of the <span class="term">value</span> array  </dd>
  <dt>deltaTimes</dt>
    <dd>The difference in seconds between the time that each corresponding element of the
      <span class="term">value</span> array was read, and the
      timeStamp field.</dd>
  <dt>alarm<dt>
    <dd>The alarm of the NTMultiChannelArray as a whole. The association of the
      values in the severities field and the alarm field is not defined since the alarm
      field refers explicitly to the value field and so not necessarily to the
      severities field (although those are likely to be related through record processing).</dd>
</dl>

<p>The above descriptions of the optional fields, pertain in particular to when a
NTMultichannelArray expresses measured values, but a NTMultichannelArray can be used
to express desired values or setpoint values too.</p>

<h3>NTTimeDomainArray</h3>

<p>NTTimeDomainArray is an EPICS V4 Normative Type that expresses an array of values
from a single signal, where there has been a constant time between each sample; for
instance from a PV that has been sampled at a given single frequency. </p>

<p>The data in a NTTimeDomainArray show how the associated signal changes over
time. <span class="ed">Should the name of the PV be included?</span></p>

<p class="ed priv">Need use cases. Also, is this definition realistic? Seems to me
you'd also want to have an indication of the sampling time error for reliable
autocorrelation. That is, if the deltaTime was .5, that would indicate that the
nominal, or expected, time between samples was .5 seconds, but you'd want also to
record an estimate of the time variance over which samples were really taken. If
that's too great, any autocorrelation is surely unreliable. Need an
expert.</p>

<pre>structure NTTimeDomainArray 
  (boolean [] | byte[] | short[] | int[] | long[] | float[] | double[])  value
  double      deltatime             // Time in seconds between each sample
  <span class="nterm">time_t</span>      basetime              // Absolute time of first sample<span class="opt">
  string      descriptor    :opt
  <span class="nterm">alarm_t</span>     alarm         :opt
  <span class="nterm">time_t</span>      timeStamp     :opt</span>
</pre>

<p>where:</p>
<dl>
  <dt>deltatime</dt>
    <dd>The constant time in seconds between each sample</dd>
  <dt>basetime</dt>
    <dd>The absolute time (UTC) at which the first sample was recorded</dd>
  <dt>value</dt>
    <dd>An array of numeric scalars, where each element gives the value of one sample</dd>
</dl>
<p class="ed">Need to include units?</p>

<h3>NTFrequencyDomainArray</h3>

<p>NTFrequencyDomainArray is the EPICS V4 Normative Type for expressing the values of
a signal with respect to frequency.</p>

<p class="ed">Needs an expert to check this. Our proto from PSI meeting defined two
numbers firstFrequency and deltaFrequency as single numbers, but surely they must
be an array of frequencies? Changed it to array, with 0 index being base freq. Maybe
harmonics should be given as deltas to the base. So we need to be more specific about
whether harmonics' frequencies are absolute or relative to frequencies[0].</p>

<pre>structure NTFrequencyDomainArray
  (boolean [] | byte[] | short[] | int[] | long[] | float[] | double[])  value
  double[] frequencies                // frequencies[0] = base, [>0] = harmonics<span class="opt">
  string      descriptor      :opt
  <span class="nterm">alarm_t</span>     alarm           :opt
  <span class="nterm">time_t</span>      timeStamp       :opt</span>
</pre>

<p>where:</p>
<dl>
  <dt>value</dt>
    <dd>The signal amplitudes at each corresponding frequency (as given by like
    numbered indexes of the <span class="term">frequencies</span> field. <span class="ed">Needs expert check</span></dd> 
  <dt>frequencies</dt>
    <dd>The signal's component frequencies in Hz. The first element MUST be the base
      component's frequency. Subsequent elements MUST be the frequency of each
      harmonic. <span class="ed">Needs expert check. eg, what order must the harmonics
      be given in, freq or power, and should they be absolute or delta from the base?</span></dd>
</dl>
<p class="ed">Need to include units?</p>

<h3>NTHistogram</h3>

<p>NTHistogram is the EPICS V4 Normative Type used to encode the data and
representation of a (1 dimensional) histogram. Specifically, it encapsulates frequency
binned data.</p>
<p>For 2d histograms (i.e. both x and y observations are binned) and n-tuple
data (e.g. land masses of different listed countries) see NTMatrix or NTTable.
</p>

<pre>structure NTHistogram
  double []  ranges                     // The start and end points of each bin 
  (short[] | int[] | long[])  counts    // The frequency count, or value of each bin<span class="opt">
  string      descriptor    :opt
  <span class="nterm">alarm_t</span>     alarm         :opt
  <span class="nterm">time_t</span>      timeStamp     :opt</span>
</pre>

<h4>Interpretation</h4>

<p>One NTHistogram gives the information required to convey a histogram
representation of some underlying observations. It does not convey the values of each
of the observations themselves.</p>

<p>The number of bins is given by the length of the  <span class="term">counts</span> array.
 <span class="term">ranges</span> indicates the low value and high value of each bin. The range for
<i>bin(i)</i> is given by <i>range(i)</i> to <i>range(i+1)</i>. Specifically, since
we want end points of both the first bin and last bin included, all bin intervals
except the last one, MUST be <i>right half
open</i>; from that bin's low value <i>range(i)</i> (included) to that bin's high
value <i>range(i+1)</i> (excluded). The last bin MUST be fully <i>open</i> (low and
high value included).</p>

<p>A log plot histogram (in which the independent variable x is binned on a log
scale), would be communicated using a range array of decades (1.0E01,
1.0E02, 1.0E03 etc).
</p>

<h4>Validation</h4>
<p>The array length of <code>range</code> MUST be the array length of counts + 1. </p>


<h3>NTAggregate</h3>

<p>NTAggregate is the EPICS V4 Normative Type to compactly convey data which
combines, several measurements, or observations. An NTAggregate would give a simple
summary statistic <a class="bib" href="#bib:agg">bib:agg</a> about the central
tendency and dispersion of a set of data points.</p>

<p>Use cases: for instance, an NTAggregate could be used to summarize the value of one
beam position offset reading over some number of pulses (N). It also includes the
time range of the sampled points, so it could be used for time domain rebasing. For
instance, an FPGA sending data at 10KHz, and you want to display its output,
but you don't want to display at the native rate.  Also, it could be used for
transmitting or storing compressed archive data.</p>

<p>NTAggregate doesn't cover the shape of a distribution so it only reasonably helps you do
symmetrical distributions (no skewness or kurtosis), and it doesn't include any help
for indicating the extent of dependency on another variable (correlation). </p>

<pre>structure NTAggregate
  double      mean                 // Average value of observations         
  double      sd                   // Standard Deviation of observations, or RMS about the mean
  long        N                    // Number of observations
  double      first           opt  // Initial observation value 
  <span class="nterm">time_t</span>      firstTimeStamp  opt  // Time of initial observation
  double      last            opt  // Final observation value
  <span class="nterm">time_t</span>      lastTimeStamp   opt  // Time of final observation
  double      max             opt  // Highest value in the N observations
  double      min             opt  // Lowest value in the N observations<span class="opt">
  string      descriptor      opt  
  <span class="nterm">alarm_t</span>     alarm           opt  
  <span class="nterm">time_t</span>      timeStamp       opt</span>
</pre>

<p>Where:</p>
<dl>
  <dt>first</dt>
  <dd>The value of the temporally first observation conveyed by this NTAggregate </dd>
  <dt>firstTimeStamp</dt>
    <dd>The time of observation of the temporally first observation conveyed by this NTAggregate</dd>
  <dt>last</dt>
  <dd>The value of the temporally final observation conveyed by this NTAggregate </dd>
  <dt>lastTimeStamp</dt>
   <dd>The time of observation of the temporally final observation conveyed by this NTAggregate</dd>
  <dt>max</dt>
    <dd>The numerically largest value in the set of observations conveyed by this NTAggregate</dd>
  <dt>min</dt>
    <dd>The numerically smallest value in the set of observations conveyed by this NTAggregate</dd>
  <dt>mean</dt>
   <dd>The mean value of the set of observations conveyed by this NTAggregate. The
     Arithmetic mean SHOULD be used.</dd>
  <dt>sd</dt>
   <dd>The standard deviation of the set of observations conveyed by this
     NTAggregate. RMS about the mean. </dd>
  <dt>N</dt>
   <dd>The number of observations represented by the data in this NTAggregate.</dd>
</dl>

<h4>Interpretation</h4>
<p>
One NTAggregate instance describes some number (given by N) of observations. If
firstTimeStamp and lastTimeStamp are given, then the N observations MUST have been taken
over the period of time specified. If first, last, max or min are given, they MUST refer
to the actual values of the N observations being summarized.  
</p>
<p>The <code>mean</code> field value computed by server agents SHOULD be the
arithmetic mean of the observation data being summarized by this NTAggregate.</p>
<p>Which estimator of the standard deviation [1/N or 1/(N-1)] is to be used by
service agents to compute the value of the <code>sd</code> field, is not defined.</p>


<h3>NTImage</h3>
<p>NTImage is the EPICS V4 Normative Type to express image data, particularly camera
images. One NTImage gives one frame.</p>

<p>The EPICS V3 image type is provided by <a
 href="http://cars9.uchicago.edu/software/epics/areaDetector.html">areaDetector</a>.
See the <a
 href="http://cars9.uchicago.edu/software/epics/areaDetectorDoxygenHTML/_n_d_array_8h_source.html">NDArray</a>
class declaration for details of the image properties. The EPICS V4 image type
(NTImage) is a superset of this functionality.</p> <p> Byte [] data may contain a
compressed image so the size may not be at least <code>prod(dim) *
element_size(datatype)</code>. </p>

<p>An NTImage is composed of three parts:</p>
<pre>structure NTImage
    <span class="nterm">Arraypart</span>
    <span class="nterm">Imagepart</span>
    <span class="nterm">Metadatapart</span>
</pre>

<p>Each of these will be discussed separately.</p>

<h4 id="L917">NTImage Array Part</h4>
<p>The     <span class="nterm">Arraypart</span> of an NTImage is composed of the
following fields:</p>
<pre>
   (boolean [] | byte[] | short[] | int[] | long[] | float[] | double[])  value
    int[]       dim
    <span class="opt">string      descriptor  :opt
    <span class="nterm">time_t</span> timeStamp        :opt
    <span class="nterm">alarm_t</span>     alarm       :opt
    <span class="nterm">display_t</span>   display     :opt</span>
</pre>

<p>These fields are the same as for NTMatrix defined previously.</p>

<p>A generic tool that operates on NTMatrixs will be able to use the image as
long as compression is not used.</p>

<h4 id="L927">NTImage Image Part</h4>
<p>The     <span class="nterm">Imagepart</span> of an NTImage is composed of the
following fields:</p>
<pre>
    int colorMode 
    int bayerPattern
    char [4] fourcc 
    int [] offset // same length as dim, start of readout
    int [] binning
    int [] reverse
    int [] fullDim
</pre>

<p>where:</p>
<dl>
  <dt>colorMode</dt>
    <dd>This is one of the following: 
      <pre>NDColorModeMono = 0,    /** Monochromatic image */
NDColorModeBayer = 1,   /** Bayer pattern image,
                            1 value per pixel but with color filter on detector */
NDColorModeRGB1 = 2,    /** RGB image with pixel color interleave,
                            data array is [3, NX, NY] */
NDColorModeRGB2 = 3,    /** RGB image with row color interleave,
                            data array is [NX, 3, NY]  */
NDColorModeRGB3 = 4,    /** RGB image with plane color interleave,
                            data array is [NX, NY, 3]  */
NDColorModeYUV444 = 5,  /** YUV image, 3 bytes encodes 1 RGB pixel */
NDColorModeYUV422 = 6,  /** YUV image, 4 bytes encodes 2 RGB pixel */
NDColorModeYUV411 = 7   /** YUV image, 6 bytes encodes 4 RGB pixels */
       </pre>
    </dd>
  <dt>bayerPattern</dt>
    <dd>This is one of the following: 
      <pre>NDBayerRGGB        = 0,    /** First line RGRG, second line GBGB... */
NDBayerGBRG        = 1,    /** First line GBGB, second line RGRG... */
NDBayerGRBG        = 2,    /** First line GRGR, second line BGBG... */
NDBayerBGGR        = 3     /** First line BGBG, second line GRGR... */
       </pre>
    </dd>
  <dt>fourcc</dt>
    <dd>Identifies codec in case of compressed data. "JPEG", for example. <a
      href="http://www.faqs.org/rfcs/rfc2361.html">List of codecs</a></dd>
  <dt>offset</dt>
    <dd>Offset for each dimension.</dd>
  <dt>binning</dt>
    <dd>The binning (pixel summation, 1=no binning) relative to original data
      source</dd>
  <dt>reverse</dt>
    <dd>The orientation (0=normal, 1=reversed) relative to the original data
      source</dd>
  <dt>fullDim</dt>
    <dd>The size of each dimension. This may be a chunk of metadata part</dd>
</dl>
<ul>
  <li>In the areaDetector colorMode and bayerPattern are stored as special
    attributes in the metadata table. In NTImage they are promoted to to
    top-level items because of their importance.</li>
  <li>bytesPerPixel, samplesPerPixel and pixelStride can be calculated from the
    image fields. Byte order isn't required because pvData deals with the byte
    order for the metadata.</li>
</ul>

<h4 id="L985">NTImage Metadata Part</h4>
<p>The     <span class="nterm">Metadatapart</span> of an NTImage is composed of the
following fields:</p>

<pre>
    int uniqueId
    string [] attributeDescriptions
    int [] attributeSourceTypes
    string [] attributeSources
    NTVariantArray [] attributes
</pre>

<p>where:</p>
<dl>
  <dt>uniqueId</dt>
    <dd>A number that must be unique for all NDArrays produced by a driver
      after it has started</dd>
  <dt>attributeDescriptions</dt>
    <dd>A description of the attribute.</dd>
  <dt>attributeSourceTypes</dt>
    <dd>
      <pre>NDAttrSourceDriver = 0,  /** Attribute is obtained directly from driver */
NDAttrSourceParam,   /** Attribute is obtained from parameter library */
NDAttrSourceEPICSPV  /** Attribute is obtained from an EPICS PV */
      </pre>
    </dd>
  <dt>attributeSources</dt>
    <dd>Source string - EPICS PV name or DRV_INFO string</dd>
  <dt>attributes</dt>
    <dd>The "table" for each attribute. Defined by an array of NTVariantArray.  </dd>
</dl>


<h2>Appendix A: Possible Future Additions to this Specification</h2>

<p>The following types may be added to this specification, following further
refinement and according to feedback to this draft. Comments welcome on these
definitions or alternatives.</p>

<h3>anydata_t</h3>
<p>anydata_t describes a pvData structure that contains an array of elements, each of
which may be a scalar array or structure array. Such structures would then be able to
transport an essentially unlimited variety of data. However, the use of anydata_t in a
Normative Type's specification would considerably complicate agent implementations
that may receive instances of those Normative Types.</p>

<pre>
<span class="nterm">anydata_t :=</span>
structure 
  {  scalar_t[] <name> | structure_t[] <name> }1+  
</pre>

<h3>NTAny</h3>

<p><span class="term">NTAny</span> would be a Normative Type for interoperation of
essentially data structure, plus description, alarm and timeStamp.</p>

<pre>
structure NTAny  
  string      description      : opt
  time_t      timeStamp     : opt
  alarm_t     alarm         : opt
  string[]    label         : opt
  <span class="nterm">anydata_t</span> value
</pre>

<h3>NTSnapShot</h3>

<p><span class="term">NTSnapshot</span> would be the Normative Type for
interoperation of EPICS V4 snapshot and configuration services, such as MASAR, with
their clients.</p>

<pre>
structure NTSnapshotData             // snapshot data [that may inc waveform ]
   time_t timeStamp                  // time of snapshot
    <span class="nterm">time_t</span>      timeStamp   :opt
    <span class="nterm">alarm_t</span>     alarm       :opt
   string[] channelNames
   alarm_t[] alarms                  // Alarm of each data value
   anydata_t value
</pre>
<p class="ed">Maybe rather than anydata_t here, we should say any Normative Type
instance? That would usefully constrain the potential types agents must
implement. </p>

<h3>NTArchive</h3>

<p><span class="term">NTArchive</span> would be the Normative Type for
interoperation of EPICS V4 capable archive services, with
their clients.</p>

<pre>
structure NTArchivedata
   string channelName                 // EPICS channel name
   time_t[] timeStamps                // Timestamps of each sample
   alarm_t[] alarms                
   anydata_t value                    
</pre>
<p class="ed">Maybe rather than anydata_t here, we should say any Normative Type
instance? That would usefully constrain the potential types agents must
implement. </p>

<h2>Bibliography</h2>
<dl>
  <dt id="bib:pvdata">[bib:pvdata]</dt>
    <dd><a href="http://epics-pvdata.sourceforge.net/development.html#pvdata">EPICS
      V4 Developer's page, pvData section</a>
    </dd>
  <dt id="bib:pvaccess">[bib:pvaccess]</dt>
  <dd><a href="http://epics-pvdata.sourceforge.net/development.html#pvaccess">EPICS
    V4 Developer's page, pvAccess section</a>
  </dd>
  <dt id="bib:epicsrecref">[bib:epicsrecref]</dt>
  <dd><a
    href="http://www.aps.anl.gov/epics/EpicsDocumentation/AppDevManuals/RecordRef/Recordref-1.html">EPICS
    Reference Manual</a>, Philip Stanley, Janet Anderson, Marty Kraimer, APS, http://www.aps.anl.gov/epics/EpicsDocumentation/AppDevManuals/RecordRef/Recordref-1.html</dd>
  <dt class="bib" id="bib:agg">bib:agg</dt>
  <dd>Aggregate data, Wikipedia article, <a
    href="http://en.wikipedia.org/wiki/Aggregate_data">http://en.wikipedia.org/wiki/Aggregate_data</a>
  </dd>
  <dt class="bib" id="bib:rdbservice">bib:rdbservice</dt>
  <dd>
    rdbService, example EPICS V4 service, <a href="http://epics-pvdata.hg.sourceforge.net/hgweb/epics-pvdata/exampleJava/file/tip/src/rdbService">http://epics-pvdata.hg.sourceforge.net/hgweb/epics-pvdata/exampleJava/file/tip/src/rdbService</a>
  </dd>
</dl>


</div>

</body>
</html>
