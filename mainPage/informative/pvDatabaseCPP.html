<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>pvDatabaseCPP</title>
  <link rel="stylesheet" type="text/css"
  href="http://epics-pvdata.sourceforge.net/base.css" />
  <link rel="stylesheet" type="text/css"
  href="http://epics-pvdata.sourceforge.net/epicsv4.css" />
  <style type="text/css">
  /*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     span.opt { color: grey }
     span.nterm { font-style:italic }
     span.term { font-family:courier }
     span.user { font-family:courier }
     span.user:before { content:"<" }
     span.user:after { content:">" }
     .nonnorm { font-style:italic }
     p.ed { color: #AA0000 }
     span.ed { color: #AA0000 }
     p.ed.priv { display: inline; }
     span.ed.priv { display: inline; }
  /*]]>*/</style>
  <!-- Script that generates the Table of Contents -->
  <script type="text/javascript"
  src="http://epics-pvdata.sourceforge.net/script/tocgen.js">
 </script>
</head>

<body>

<div class="head">
<h1>pvDatabaseCPP</h1>
<!-- Maturity: Working Draft or Request for Comments, or Recommendation, and date. -->

<h2 class="nocount">EPICS v4 Working Group, Working Draft, 09-Nov-2012</h2>
<dl>
    <dt>Latest version:</dt>
    <dd><a
      href="pvDatabaseCPP.html">pvDatabaseCPP.html</a>
    </dd>
    <dt>This version:</dt>
    <dd><a
      href="pvDatabaseCPP.html">pvDatabaseCPP.html</a>
    </dd>
    <dt>Previous version:</dt>
    <dd>None</dd>
  <dt>Editors:</dt>
    <dd>Marty Kraimer, BNL</dd>
</dl>

  <p class="copyright">This product is made available subject to acceptance of the <a
href="http://epics-pvdata.sourceforge.net/LICENSE.html">EPICS open source license.</a></p>
<hr />
</div>

<h2 class="nocount">Abstract</h2>

<p>This document describes pvDatabaseCPP,
which is a framework for implementing a network accessable database of smart memory resident
records. Network access is via pvAccess. The data in each record is a top level PVStructure as defined by
pvData. The framework includes a complete implementation of ChannelProvider as defined by pvAccess.
The framework must be extended in order to create record instances.
The minimum that an extenson must provide is a top level PVStructure and a process method
but the framework provides for complex extensions.</p>

<p>EPICS version 4 is a set of related products in the EPICS
V4 control system programming environment:</p>
<dl>
  <dt><a
  href="http://epics-pvdata.hg.sourceforge.net/hgweb/epics-pvdata/pvDataJava/raw-file/tip/documentation/pvDataJava.html">pvData</a></dt>
    <dd>pvData (Process Variable Data) defines and implements an efficent way
      to store, access, and communicate memory resident structured data</dd>
  <dt><a
  href="http://epics-pvdata.hg.sourceforge.net/hgweb/epics-pvdata/pvAccessJava/raw-file/tip/documentation/pvAccessJava.html">pvAccess</a></dt>
    <dd>pvAccess is a software library for high speed controls network communications,
      optimized for pvData</dd>
  <dt><a
  href="http://epics-pvdata.hg.sourceforge.net/hgweb/epics-pvdata/pvIOCJava/raw-file/tip/documentation/pvIOCJava.html">pvIOC</a></dt>
    <dd>pvIOC is a software framework for building network accessable "smart" real time
      databases, suitable for interfacing devices in a distributed control system,
      that can exchange pvData over pvAccess.
    </dd>
  <dt><a
  href="http://epics-pvdata.hg.sourceforge.net/hgweb/epics-pvdata/pvServiceJava/raw-file/tip/documentation/pvAccessJava.html">pvService</a></dt>
    <dd>A middle layer for implementing data services.</dd>
</dl>

<p>Each of these products has a Java and a C++ implementation.</p>

<h2 class="nocount">Status of this Document</h2>

<p>This is the 09-Nov-2012 version of the definition of pvDatabaseCPPCPP.
This is the original version.
</p>
<p><b>VERY EARLY DRAFT:</b> This is the first thoughts about what pvDataBaseCPP should be.
It is intended to descibe the features that will be provided.
The class definitions provide a "feeling" for what is required for the first phase
but will require changes before they have valid C++ syntax.</p>


<div id="toc">
<h2 class="nocount" style="page-break-before: always">Table of Contents</h2>
</div>
<div id="contents" class="contents">


<h2>Introduction</h2>
<h3>Overview</h3>
<p>This document descibes a C++ implementation of some of the components in pvIOCJava.
It extracts the core components required to create a network accessible database of smart
memory resident records.
pvDatabaseCPP does not and will not implement any of the specialized support that pvIOCJava
provides. Instead other projects will implement the specialized support.
It is expected that many services will be created that do not require the full features provided
by pvIOCJava. In the future pvIOCJava should be split into multiple projects with one of 
them named pvDatabaseJava.
</p>

<p>A brief description of a pvDatase is that it is a network accessible set of smart memory resident
records. Each record has data composed of a top level PVStructure. Each record has a name which is
the channelName for pvAccess. A local Channel Provider implements the complete ChannelProvider and
Channel interfaces as defined by pvAccess.
This local provider  is accessed by the remote pvAccess server.s
A record is smart because code can be attached to a record.</p>
<p>This document describes components that provides the following features:
<dl>
  <dt>pvRecord</dt>
     <dd>This encapuslates the concept of a smart record. It can be processed.
     Changes to field values can be trapped. A record can be locked.</dd>
  <dt>pvDatabase<dt>
      <dd>This is a database of pvRecords. Records can be added and removed from a database.</dd>
  <dt>Local Channel Provider</dt>
     <dd>This is a complete implementation of ChannelProvider and Channel as defined by pvAccess.
       It is used by the server side of pvAccess to attach to pvRecords.
       This component also includes the monitor and pvCopy components from pvIOCJava</dd>
</dl>
<p>pvDatabase does not itself implement pvRecord instances. Instead it provides a set of base classes
that make it easy to create record instances. All that has to be implemented is a top
level PVStructure and a <b>process</b> method</p>
<h3>Example Extension</h3>
<p>The following is an example that implements a counter:</p>
<pre>
class MySupport;
typedef std::tr1::sharedPtr MySupportPtr;

class MySupport : public extends Support {
public:
    virtual void process(ProcessRequesterPtr const &amp; processRequester);
    MySupport(PVStructurePtr const &amp; pvStructure);
private:
    PVLongPtr pvValue;
};

MySupport::MySupport(PVStructurePtr const &amp;pvStructure)
: pvValue(pvStructure-&gt;.getLongField("value")
{}

void MySupport::process(ProcessRequesterPtr const &amp; processRequester)
{
    pvValue-&gt;put(pvValue->get() + 1);
    processRequester-&gt;processDone();
}

int main()
{
    PVStructurePtr pvStructure = getStandardPVField()-&gt;.scalar(pvLong):
    MySupportPtr support = MySupportPtr(new MySupport(pvStructure));
    PVRecordPtr pvRecord = getPVRecordCreate(
        "exampleRecord", pvStructure,support);
    getPVDatabase()-&gt;.addRecord(pvRecord);
    while(true) {}
    return 0
}
</pre>
<p>where</p>
<dl>
   <dt>MySupport</dt>
     <dd>This extends interface Support, described below. It only implements two methods:
      The constructor and method process. The constructor expects the be passed a top level
      PVStructure that has a field named <b>value</b> that is a pvLong.
      The process method just increments the value.</dd>
   <dt>main</dt>
     <dd>Does the following:
        <dl>
          <dt>Creates pvStructure</dt>
          <dt>Creates support</dt>
          <dt>Creates pvRecord</dt>
          <dt>Adds the record to the database</dt>
          <dt>Waits forever</dt>
        </dl>
     </dd>
</dl>
<p>Until the process is killed pvAccess clients can put and get the value field. For example</p>
<pre>
pvget exampleRecord
pvput exampleRecord 5
</pre>
<p>Will both work.</p>
<h3>Phased Development</h3>
<p>This documentation describes the first phase of a phased implementation of pvDatabaseCPP:</pp>
<dl>
   <dt>pvRecord</d>
      <dd>Wrapper on PVStructure that implements methods required by Local Channel Provider.</dd>
   <dt>pvDatabase</d>
      <dd>Database of PVRecords. Has methods find, add, and remove.</dd>
   <dt>Local Channel Provider</dt>
      <dd>These two features will be the first phase.
        But only synchronous record processing will be supported.</dd>
</dl>
<p>Future phases of pvRecordCPP should include:</p>
<dl>
   <dt>Install</dt>
      <dd>This provides on-line add and delete.</dd>
   <dt>Field support</dt>
      <dd>Add ability to optionally add support to fields.
       In addition some of the basic support defined in pvIOCJava will also be implemented.</dd>
   <dt>Asynchronous</dt>
      <dd>Add support for asynchronous processing.
        This means for both record and fields.</dd>
   <dt>XML parser</dt>
      <dd>This provides the ability to create record instances without writing any code.</dd>
</dl>
<p>The completion of each phase provides useful features that can be used without waiting for the
completion of later phases.
The rest of this  document discusses only the first phase.</p>
<h3>Features Required for Channel Provider</h3>
<dl>
   <dt>pvCopy</dt>
      <dd>Creates a PVStructure that contains a copy of an arbitary
          subset of the fields of another top level PVStructure.
        It can copy data between the two and maintains a bitSet that show
        which fields are changed.<dd>
   <dt>monitor</dt>
      <dd>This provides the ability to monitor changes to fields of a record.</dd>
   <dt>PVRecord</dt>
      <dd>PVRecord as defined below.</dd>
   <dt>local ChannelProvider</dt>
     <dd>This is the pvAccess package in pvIOCJava.
       The localChannelProvider will access data from PVRecords.
     It will implement all channel methods except channelRPC.</dd>
</dl>
<h3>Minumum Features Required for pvRecord</h3>
<p>The first phase will only implement synchonous record processing, i. e.
the process method does not return until it completes processing even if it has to block.
The following are the minimium features required</p>
<dl>
  <dt>Support</dt>
     <dd>Support has life cycle methods and a method named <b>process</b>
        The life cycle methods are not used in the first phase. Thus the only method
        extensions need to implement is <b>process</b>.
  <dt>PVDatabase</dt>
      <dd>This holds a set of PVRecords. It has methods to find, add, and remove records.</dd>
  <dt>PVRecord</dt>
     <dd>This, and a set of related interfaces, provide the following:
        <dl>
           <dt>PVStructure</dt>
             <dd>PVRecord is a wrapper on a top level pvStructure.</dd>
           <dt>Record locking</dt>
              <dd>A record can be locked and unlocked.
              A record must be locked whenever data in the pvStructure is accessed.</dd>
           <dt>Trapping data changes</dt>
             <dd>A client can request to be notified when data in the pvStructure is modified.
             It can do this on a field by field basis.</dd>
        </dl>
     </dd>
</dl>
<p>The following two sections provide a first attempt to describe the classes required for the first
phase.</p>
<p>The last section gives a brief overview of the features provided by pvIOCJava.</p>

<h2>pvRecord</h2>
<h3>Support</h3>
<pre>
class ProcessRequester;
typedef std::tr1::shared_ptr<ProcessRequester> ProcessRequesterPtr;

class ProcessRequester {
    void processDone(Status status);
};

class Support;
typedef std::tr1::shared_ptr<Support> SupportPtr;

class Support : public Requester {
public:
    virtual Status initialize(PVRecordFieldPtr const &amp; pvRecordField);
    virtual Status start();
    virtual Status stop();
    virtual Status uninitialize();
    virtual void process(ProcessRequester const &amp; processRequester);
};
</pre>
<h3>PVRecord</h3>
<pre>
class PVListener;
typedef std::tr1::shared_ptr<PVListener> PVListenerPtr;

class PVListener {
public:
    void dataPut(PVRecordField pvRecordField);
    void dataPut(PVRecordStructure requested,PVRecordField pvRecordField);
    void beginGroupPut(PVRecord pvRecord);
    void endGroupPut(PVRecord pvRecord);
    void unlisten(PVRecord pvRecord);
};

class PVRecordClient;
typedef std::tr1::shared_ptr<PVRecordClient> PVRecordClientPtr;

class PVRecordClient {
    void detach(PVRecord pvRecord);
};

class PVRecord;
typedef std::tr1::shared_ptr<PVRecord> PVRecordPtr;

class PVRecord : public Requester, public Support {
public:
    virtual void lock();
    virtual void unlock();
    PVRecordField findPVRecordField(PVField pvField);
    PVRecordStructure getPVRecordStructure();
    String getRecordName();
    void message(String message, MessageType messageType);
    void addRequester(Requester requester);
    void removeRequester(Requester requester);
    void lockOtherRecord(PVRecord otherRecord);
    void beginGroupPut();
    void endGroupPut();
    void registerListener(PVListener pvListener);
    void unregisterListener(PVListener pvListener);
    boolean isRegisteredListener(PVListener pvListener);
    void removeEveryListener();
    void registerClient(PVRecordClient pvRecordClient);
    void unregisterClient(PVRecordClient pvRecordClient);
    void detachClients();
    int getNumberClients();
    String toString();
    String toString(int indentLevel);
};

class PVRecordStructure;
typedef std::tr1::shared_ptr<PVRecordStructure> PVRecordStructurePtr;

class PVRecordStructure : public PVRecordField {
public:
    PVRecordField[] getPVRecordFields();
    PVStructurePtr getPVStructure();
}

class PVRecordField;
typedef std::tr1::shared_ptr<PVRecordField> PVRecordFieldPtr;

class PVRecordField : extends Requester {
public:
    PVRecordStructure getParent();
    PVField getPVField();
    String getFullFieldName();
    String getFullName();
    PVRecord getPVRecord();
    boolean addListener(PVListener pvListener);
    void removeListener(PVListener pvListener);
    void postPut();
};

class PVRecordCreate;
typedef std::tr1::shared_ptr<PVRecordCreate> PVRecordCreatePtr;

class PVRecordCreate {
public:
    PVRecord createPVRecord(
        String recordName,
        PVStructure pvStructure,
        Support support);
};

extern PVRecordCreatePtr getPVRecordCreate();
</pre>
<h3>database</h3>
<pre>
class PVDatabase;
typedef std::tr1::shared_ptr<PVDatabase> PVDatabasePtr;

class PVDatabase : public Requester {
public:
    PVRecord findRecord(String recordName);
    boolean addRecord(PVRecord record);
    boolean removeRecord(PVRecord record);
}
</pre>
<h3>Future</h3>
<p>The above is sufficent for synchronous record processing, i. e.
process does not return until it completes.
pvIOCJava implements <b>RecordProcess</b> which is support for asynchrous
processing. This needs to be done but not for initial implementation.</p>
<h2>Local Channel Provider</h2>
<p>Not yet described.</p>
<p>A brief description is that it must implement the following components of pvIOCJava:</p>
<dl>
   <dt>pvCopy</dt>
   <dt>monitor</dt>
   <dt>pvAccess</dt>
      <dd>See the next section for a description</dd>
</dl>
<h2>Summary of Packages in pvIOCJAVA</h2>
<p>The following are the direct sub packages of <b>pvIOCJava/src/org/epics/pvioc</b>:</p>
<dl>
   <dt>pvCopy</dt>
     <dd>This provides a copy of an arbitrary subset of the fields in a PVRecord.
      It also provides the ability to detect and report changes to fields.
      It is required for pvAccess.</dd>
   <dt>monitor</dt>
     <dd>This provides the ability to monitor changes to a PVRecord. It is required for pvAccess monitors.</dd>
   <dt>pvAccess</dt>
      <dd>The local implementation of Channel Provider and Channel.
       It is accessed by the remote pvAccess server and can also be accessed by code in the same IOC.</dd>
   <dt>database</dt>
     <dd>This defines and implements PVRecord, PVDatabase , and PVListener.
      It supports the basic feature required the implement a local Channel Provider.</dd>
   <dt>support</dt>
       <dd>This provides the ability to optionally attach code to any field of a pvRecord.
        It and several sub packages provide a set of standard support modules.</dd>
   <dt>install</dt>
      <dd>This provides the ability to dynamically initialize and add new PVRecords. It also provides
      the ability to dynamicall delete PVRecords.</d> 
   <dt>xml</dt>
      <dd>This provides the ability to configure record instances without writing code.</dd>
   <dt>util</dt>
     <dd>This is misnamed since it is code related to scanning.</dd>
   <dt>pdrv</dt>
      <dd>This is portDriver, which is a proposed sucessor to the asynManager component of asynDriver.</dd>
   <dt>swtshell</dt>
      <dd>This is shell that is can either run under the same process as a JavaIOC or as a remote shell.
       It is like a version of probe but for pvData/pvAccess.
      Almost all of it's features work in either local or remote mode.
      With a little more work all or it's features could work remotely.
      This should be done and then only remote mode should be supported.
      It can then be rewritten in a completely different language and using a complely different GUI
      framework.
     </dd>
   <dt>caV3</dt>
      <dd>This has two components:
       <dl>
        <dt>ClientFactory</dt>
          <dd>This is a small wrapper on top of the caV3 client support implemented by pvAccess.
           It allows code in the pvIOC to access V3Records via pvAccess.</dd>
        <dt>ServerFactory</dt>
          <dd>This is a caV3 server that allows a caV3 client to access a PVRecord.
          The Java implementation uses CAJ, which does most of the work.
          For now it will not be discussed in this document.</dd>
       </dl>
     </dd>
   <dt>v3a</dt>
     <dd>I do not know what this is.</dd>
</dl>
<p>In addition there is one class file <b>JavaIOC.java</b>.
This is starting a IOC instance.
This is not required for pvIOCCPP which is either a main or runs as part of a V3 IOC.</p>

</div>
</body>
</html>
